{"mappings":"AAWA;IACE,KAAK,EAAE,MAAM,CAAC;IACd,KAAK,EAAE,MAAM,CAAC;IACd,IAAI,EAAE,MAAM,CAAC;IACb,WAAW,EAAE,MAAM,CAAC;IACpB,YAAY,EAAE,MAAM,CAAC;IACrB,MAAM,CAAC,EAAE,CAAC,GAAG,EAAE,MAAM,GAAG,IAAI,GAAG,SAAS,KAAK,MAAM,CAAC;IACpD,SAAS,CAAC,EAAE,CAAC,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,KAAK,MAAM,CAAC;IAClD,QAAQ,EAAE,CAAC,GAAG,EAAE,MAAM,KAAK,IAAI,CAAC;CACjC;AAKD,OAAO,MAAM,uBAAwB,MAAM,GAAG,IAAI,GAAG,SAAS,KAAG,MAKhE,CAAC;AAEF,OAAO,MAAM,0BAA2B,MAAM,QAAQ,MAAM,KAAG,MAW9D,CAAC;AAmDF,OAAO,MAAM,kGASV,mBAAmB,gBAsLrB,CAAC","sources":["packages/react-fmt-input/src/src/react-fmt-input.tsx","packages/react-fmt-input/src/react-fmt-input.tsx"],"sourcesContent":[null,"import React, {\n  FormEvent,\n  useState,\n  KeyboardEvent,\n  useRef,\n  MouseEvent,\n  useCallback,\n  useEffect,\n} from 'react';\n\n\nexport interface FormattedInputProps {\n  label: string;\n  value: string;\n  mask: string;\n  placeholder: string;\n  errorMessage: string;\n  parser?: (str: string | null | undefined) => string;\n  formatter?: (str: string, mask: string) => string;\n  onChange: (str: string) => void;\n}\n\n\nconst MASK_CHARS = ['^', '_', '#', undefined];\n\nexport const defaultParser = (value: string | null | undefined): string => {\n  if (value === null || value === undefined) {\n    return '';\n  }\n  return value.replace(/[^A-ZА-Я0-9]/gi, '');\n};\n\nexport const defaultFormatter = (value: string, mask: string): string => {\n  let result = [];\n  for (let i = 0, m = 0; m < mask.length; ++m) {\n    if (MASK_CHARS.includes(mask[m])) {\n      if (i >= value.length) break;\n      result.push(value[i++]);\n    } else {\n      result.push(mask[m]);\n    }\n  }\n  return result.join('');\n};\n\nconst getStartPosition = (mask: string): number => {\n  let startPos = 0;\n  while (!MASK_CHARS.includes(mask[startPos]) && startPos < mask.length) {\n    startPos++;\n  }\n  return startPos;\n};\n\nconst getValuePosition = (\n  value: string,\n  mask: string,\n  maskPos: number,\n): number => {\n  let pos = 0;\n  for (let i = 0; i < maskPos; ++i) {\n    if (MASK_CHARS.includes(mask[i])) {\n      pos++;\n    }\n  }\n  return pos;\n};\n\nconst setCaret = (\n  target: HTMLInputElement,\n  pos: number,\n  callback?: () => number,\n) => {\n  requestAnimationFrame(() => {\n    if (callback) {\n      pos = callback();\n    }\n    target.setSelectionRange(pos, pos);\n  });\n};\n\nconst getMaskPosition = (\n  value: string,\n  mask: string,\n  valuePos: number,\n): number => {\n  let pos = 0;\n  for (let i = 0; pos < mask.length && i < valuePos; ++pos) {\n    if (MASK_CHARS.includes(mask[pos])) {\n      i++;\n    }\n  }\n  return pos;\n};\n\nexport const FormattedInput = ({\n  label,\n  value,\n  parser,\n  mask,\n  placeholder,\n  errorMessage,\n  formatter,\n  onChange,\n}: FormattedInputProps) => {\n  parser = parser || defaultParser;\n  formatter = formatter || defaultFormatter;\n\n  const ref = useRef<HTMLInputElement | null>(null);\n  const formattedValue = formatter(value, mask);\n  const id = useRef(Math.random().toString(36));\n  const [error, setError] = useState(false);\n  const errorBorder = error ? {border: '2px solid red'} : {};\n\n  const getPattern = useCallback(\n    (value: string): string => {\n      if (value.length === 0) {\n        return '';\n      }\n\n      const maskChars = mask.split('').slice(0, value.length);\n      maskChars.unshift('');\n      const reStr = maskChars\n        .join('\\\\')\n        .replace(/\\\\#/g, '\\\\d')\n        .replace(/\\\\\\^/g, '[A-ZА-Я]')\n        .replace(/\\\\_/g, '[a-zа-я]');\n\n      return `^${reStr}$`;\n    },\n    [mask],\n  );\n\n  const validate = useCallback(\n    (value: string, showError: boolean): boolean => {\n      if (value.length === 0) {\n        showError && setError(false);\n        return true;\n      }\n\n      const re = new RegExp(getPattern(value));\n\n      if (re.test(value)) {\n        showError && setError(false);\n        return true;\n      } else {\n        showError && setError(true);\n        return false;\n      }\n    },\n    [mask],\n  );\n\n  const handleInput = useCallback(\n    (e: FormEvent<HTMLInputElement>) => {\n      // @ts-ignore\n      const target = e.target as HTMLInputElement;\n      const value = target.value.substr(0, mask.length);\n      let savePos = target.selectionStart || getStartPosition(mask);\n      const parsedValue = parser ? parser(value) : value;\n\n      onChange(parsedValue);\n      if (savePos < value.length) {\n        setCaret(target, savePos);\n      }\n    },\n    [parser, onChange, mask],\n  );\n\n  const handleKeyDown = useCallback(\n    (e: KeyboardEvent) => {\n      let caret = ref.current?.selectionStart || getStartPosition(mask);\n      const target = e.target as HTMLInputElement;\n\n      switch (e.key) {\n        case 'ArrowUp':\n        case 'Home':\n        case 'Escape':\n          if (e.key === 'Escape') {\n            onChange('');\n          }\n          const pos = getStartPosition(mask);\n\n          setCaret(target, pos);\n          e.preventDefault();\n          e.stopPropagation();\n          break;\n\n        case 'Backspace': {\n          const valuePos = getValuePosition(value, mask, caret);\n          const newValue = `${value.substring(0, valuePos - 1)}${value.substring(valuePos, value.length)}`;\n          let maskPos = getMaskPosition(newValue, mask, valuePos);\n\n          maskPos = Math.max(maskPos - 1, getStartPosition(mask));\n          onChange(newValue);\n          setCaret(target, maskPos);\n          e.preventDefault();\n          e.stopPropagation();\n          break;\n        }\n\n        case 'Delete': {\n          const valuePos = getValuePosition(value, mask, caret);\n          const newValue = `${value.substring(0, valuePos)}${value.substring(\n            valuePos + 1,\n            value.length,\n          )}`;\n\n          onChange(newValue);\n          setCaret(target, caret);\n          e.preventDefault();\n          e.stopPropagation();\n          break;\n        }\n      }\n    },\n    [mask, value, onChange],\n  );\n\n  const handleMouseDown = useCallback(\n    (e: MouseEvent) => {\n      // @ts-ignore\n      const target = e.target as HTMLInputElement;\n      setCaret(target, 0, () => {\n        const start = getStartPosition(mask);\n        if ((target.selectionStart || 0) < start) {\n          return start;\n        }\n        return target.selectionStart || 0;\n      });\n    },\n    [mask],\n  );\n\n  useEffect(() => {\n    validate(formattedValue, true);\n  }, [formattedValue, validate]);\n\n  return (\n    <div style={{height: '2.5rem'}}>\n      <label htmlFor={id.current} style={{display: 'flex'}}>\n        <span style={{margin: '5px'}}>{label} </span>\n        <div style={{display: 'relative'}}>\n          <input\n            style={{\n              position: 'absolute',\n              color: '#a9a9a9',\n              pointerEvents: 'none',\n              border: '2px solid transparent',\n              outline: 'none',\n            }}\n            tabIndex={-1}\n            value={formattedValue.concat(\n              placeholder.slice(formattedValue.length),\n            )}\n            onChange={() => {\n            }}\n          />\n          <input\n            id={id.current}\n            style={{\n              position: 'absolute',\n              caretColor: 'black',\n              background: 'transparent',\n              ...errorBorder,\n            }}\n            ref={ref}\n            value={formattedValue}\n            onInput={handleInput}\n            onKeyDown={handleKeyDown}\n            onMouseDown={handleMouseDown}\n          />\n          <div\n            style={{\n              color: 'red',\n              position: 'relative',\n              top: '1.4rem',\n              fontSize: 12,\n            }}\n          >\n            {error && errorMessage}\n          </div>\n        </div>\n      </label>\n    </div>\n  );\n};\n"],"names":[],"version":3,"file":"types.d.ts.map"}